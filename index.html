<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Specl - Analyser : An Assertion Language for Service Data Object" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Specl - Analyser</title>
  </head>

  <body>
    
    <a id="btt" href="#main_content_wrap" title="Click to go to top">&nbsp;<img src="images/btt.png" /></a>
        
    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/samguinea/specl">View on GitHub</a>

          <h1 id="project_title">Specl - Analyser</h1>
          <h2 id="project_tagline">An Assertion Language for Service Data Object</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/samguinea/specl/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/samguinea/specl/tarball/master">Download this project as a tar.gz file</a>
            </section>
            
          <nav>
            <ul>
              <li><a href="index.html">Home</a></li>
              <li>Examples
                <ul>
                  <li><a href="bookstore.html">Didactic Example</a></li>
                  <li><a href="soaphandler.html">SOAP Handler</a></li>
                  <li><a href="twitterrest.html">Twitter REST</a></li>
                </ul>
              </li>
            </ul>
          </nav>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="specl-language" class="anchor" href="#specl-language"><span class="octicon octicon-link"></span></a>Specl Language</h1>

<p><a name="top"></a>
Specl is a special-purpose assertion DSL for the expression of monitoring directives and constraint.</p>

<p>Specl concentrates on both functional and non-functional properties, and is suitable to express general dependability properties such as safety, integrity, availability and reliability.</p>

<p>The main strength of this language is that it relies on the concept of Service Data Object (SDO). This gives the language a single consistent view of data obtained from a variety of sources, and takes Specl to a more high level of abstraction. Specl acquires power and flexibility thanks to SDOs, allowing it to be used in various different contexts.</p>

<p>In this chapter, we will explain the language characteristics and features, decorating explanations with little examples (extracted and base on the work done in the <a href="example.html">BookStore Example</a> for a better understanding. It would be useful at least a basic knowledge of navigational path and XPath.</p>

<p>The presentation will be done in a bottom-up fashion, from the data types to the whole grammar structure.</p>

<h2>
<a name="table-of-content" class="anchor" href="#table-of-content"><span class="octicon octicon-link"></span></a>Table of Content</h2>

<ol>
<li>
<a href="#data-types">Data Types</a>

<ol>
<li><a href="#sdo">SDO</a></li>
<li><a href="#array">Array</a></li>
<li><a href="#string">String</a></li>
<li><a href="#double">Number</a></li>
</ol>
</li>
<li>
<a href="#lexical_elems">Other Lexical Elements</a>

<ol>
<li><a href="#comments">Comments</a></li>
<li><a href="#keyword">Keyword</a></li>
<li><a href="#operators">Operators</a></li>
</ol>
</li>
<li>
<a href="#features">Features</a>

<ol>
<li><a href="#navigation-and-query">Navigation &amp; Query</a></li>
<li><a href="#declaration">Declaration</a></li>
<li>
<a href="#assertion">Assertions</a>

<ol>
<li><a href="#quantified-assertion--aggregated-functions">Quantified Assertion &amp; Aggregated Functions</a></li>
<li><a href="#numeric-expression">Numeric Expression</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#grammar">Grammar</a></li>
</ol><p><a name="data_types"></a></p>

<h2>
<a name="data-types" class="anchor" href="#data-types"><span class="octicon octicon-link"></span></a>Data Types</h2>

<p>The data types used inside the language are</p>

<ul>
<li>SDO</li>
<li>Array</li>
<li>String</li>
<li>Double</li>
<li>Boolean</li>
</ul><p>Each of them as associated its own functions, that expands the power of the language and that could be easily upgraded and extended. SDO, as a containment object, could have values of each of the previously showed type, even another SDO.</p>

<p><a name="sdo"></a></p>

<h3>
<a name="sdo" class="anchor" href="#sdo"><span class="octicon octicon-link"></span></a>SDO</h3>

<p>SDO was born for simplify and unify Service Oriented Architecture (SOA) data access and code, i.e. its purpose is to facilitate communication and, for this reason, are designed to deliver a uniform data access layer for heterogeneous data sources in a service-oriented architecture. Provides flexible data structures that allow data to be organized as graphs of objects (called <em>data object</em>) that are composed of <em>properties</em>. Properties can be single or many valued and can have other data objects as their values.</p>

<h4>
<a name="mapping-examples" class="anchor" href="#mapping-examples"><span class="octicon octicon-link"></span></a>Mapping Examples</h4>

<p>The Specl interpreter, provided as final result of this thesis, gives the possibility to translate XML documents and JSON objects to SDO. Furthermore, thanks to the generality and abstraction of SDOs, developers could build their own translator for any type of data.</p>

<p>For example, starting from the next XML and JSON code could be obtained a simple SDO.</p>

<p>XML:</p>

<div class="highlight highlight-XML"><pre><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;container&gt;</span>
    <span class="nt">&lt;elem1&gt;</span>String<span class="nt">&lt;/elem1&gt;</span>
    <span class="nt">&lt;elem2&gt;</span>1<span class="nt">&lt;/elem2&gt;</span>
    <span class="nt">&lt;elem3&gt;</span>A<span class="nt">&lt;/elem3&gt;</span>
    <span class="nt">&lt;elem3&gt;</span>B<span class="nt">&lt;/elem3&gt;</span>
    <span class="nt">&lt;elem3&gt;</span>C<span class="nt">&lt;/elem3&gt;</span>
    <span class="nt">&lt;elem4&gt;</span>true<span class="nt">&lt;/elem4&gt;</span>
    <span class="nt">&lt;elem5&gt;</span>
        <span class="nt">&lt;sub-elem1&gt;</span>String<span class="nt">&lt;/sub-elem1&gt;</span>
        <span class="nt">&lt;sub-elem2&gt;</span>
            <span class="nt">&lt;sub-sub-elem1&gt;</span>10<span class="nt">&lt;/sub-sub-elem1&gt;</span>
        <span class="nt">&lt;/sub-elem2&gt;</span>
        <span class="nt">&lt;sub-elem3&gt;</span>1<span class="nt">&lt;/sub-elem3&gt;</span>
        <span class="nt">&lt;sub-elem3&gt;</span>2<span class="nt">&lt;/sub-elem3&gt;</span>
    <span class="nt">&lt;/elem5&gt;</span>
<span class="nt">&lt;/container&gt;</span>
</pre></div>

<p>JSON:</p>

<div class="highlight highlight-JSON"><pre><span class="p">{</span>
    <span class="nt">"elem1"</span><span class="p">:</span> <span class="s2">"String"</span><span class="p">,</span>
    <span class="nt">"elem2"</span><span class="p">:</span> <span class="s2">"1"</span><span class="p">,</span>
    <span class="nt">"elem3"</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">"A"</span><span class="p">,</span>
        <span class="s2">"B"</span><span class="p">,</span>
        <span class="s2">"C"</span>
    <span class="p">],</span>
    <span class="nt">"elem4"</span><span class="p">:</span> <span class="s2">"true"</span><span class="p">,</span>
    <span class="nt">"elem5"</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">"sub-elem1"</span><span class="p">:</span> <span class="s2">"String"</span><span class="p">,</span>
        <span class="nt">"sub-elem2"</span><span class="p">:</span> <span class="p">[</span>
            <span class="s2">"10"</span>
        <span class="p">],</span>
        <span class="nt">"sub-elem3"</span><span class="p">:</span> <span class="p">[</span>
            <span class="s2">"1"</span><span class="p">,</span>
            <span class="s2">"2"</span>
        <span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Here is the structure of the SDO derived from the previous languages:</p>

<pre><code>{
    container = {
        elem1 = "String",
        elem2 = 1,
        elem3 = ["A", "B", "C"],
        elem4 = true,
        elem5 = {
            sub-elem1 = "String",
            sub-elem2 = {
                sub-sub-elem1 = 10
            },
            sub-elem3 = [1, 2]
        }
    }
}
</code></pre>

<p>As you can see, the representation is pretty similar to JSON: sets of key-value entry and ordered lists of values.</p>

<h4>
<a name="functions" class="anchor" href="#functions"><span class="octicon octicon-link"></span></a>Functions</h4>

<p>SDO’s functions let the designer to operate both on the whole object and on the elements included into it (could be checked the presence of a certain property or get its value).
The following is the list of available functions (plus a short example for each one):</p>

<h5>
<a name="boolean-containsobject-elem" class="anchor" href="#boolean-containsobject-elem"><span class="octicon octicon-link"></span></a><strong>boolean contains(Object elem)</strong>
</h5>

<p>returns <em>true</em> if an object with elem value is contained (the research is deep)</p>

<pre><code>// search "Pocket" string in the first book of the inventory
/inventory/book[1].contains("Pocket")
</code></pre>

<h5>
<a name="object-getint-index" class="anchor" href="#object-getint-index"><span class="octicon octicon-link"></span></a><strong>Object get(int index)</strong>
</h5>

<p>returns the value of the <code>index</code>-th node (the first element of the array has index equals to 1)</p>

<pre><code>// returns the first book of the inventory
/inventory.get(1)
</code></pre>

<h5>
<a name="object-getstring-node" class="anchor" href="#object-getstring-node"><span class="octicon octicon-link"></span></a><strong>Object get(String node)</strong>
</h5>

<p>returns the value of the node with name <code>node</code></p>

<pre><code>// get the value of the key "name"
/inventory.get("name")
</code></pre>

<h5>
<a name="double-cardinality" class="anchor" href="#double-cardinality"><span class="octicon octicon-link"></span></a><strong>double cardinality()</strong>
</h5>

<p>returns the number of elements contained</p>

<pre><code>// get the number of values contained
/inventory.cardinality();
</code></pre>

<p><a name="array"></a></p>

<h3>
<a name="array" class="anchor" href="#array"><span class="octicon octicon-link"></span></a>Array</h3>

<p>The used type coincide with the classical kind of array, containing a finite number of elements. It is defined writing the elements of it inside square brackets and separated by commas (<code>[elem1, elem2, ...]</code>).</p>

<h4>
<a name="functions-1" class="anchor" href="#functions-1"><span class="octicon octicon-link"></span></a>Functions</h4>

<p>Available functions for arrays covers the basic general-purpose language functions for this kind of data type, working on elements or getting the size of the array:</p>

<h5>
<a name="boolean-containsobject-elem-1" class="anchor" href="#boolean-containsobject-elem-1"><span class="octicon octicon-link"></span></a><strong>boolean contains(Object elem)</strong>
</h5>

<p>returns <em>true</em> if the passed <code>elem</code> object is contained</p>

<pre><code>// check if the second book is written by a certain author
/inventory/book[2]/authors/author.contains("Larry Niven")
</code></pre>

<h5>
<a name="object-getint-index-1" class="anchor" href="#object-getint-index-1"><span class="octicon octicon-link"></span></a><strong>Object get(int index)</strong>
</h5>

<p>returns the <code>index</code>-th element of the array</p>

<pre><code>// get the second author from an array of authors,
// from the second book
/inventory/book[2]/authors/author.get(2)
</code></pre>

<h5>
<a name="double-cardinality-1" class="anchor" href="#double-cardinality-1"><span class="octicon octicon-link"></span></a><strong>double cardinality()</strong>
</h5>

<p>returns the length of the array</p>

<pre><code>// get the length of the authors array of the second book
/inventory/book[2]/authors/author.cardinality()
</code></pre>

<p><a name="string"></a></p>

<h4>
<a name="string" class="anchor" href="#string"><span class="octicon octicon-link"></span></a>String</h4>

<p>Represents a string constant obtained from a sequence of characters. Everything inside quotes is considered as string (double or single quote: <code>"..."</code> or <code>’...’</code>).</p>

<h5>
<a name="functions-2" class="anchor" href="#functions-2"><span class="octicon octicon-link"></span></a>Functions</h5>

<p>Even in this case, the functions are simple and common in many other contexts:</p>

<h5>
<a name="string-uppercase" class="anchor" href="#string-uppercase"><span class="octicon octicon-link"></span></a><strong>String uppercase()</strong>
</h5>

<p>turns every character to uppercase</p>

<pre><code>// inventory’s name to uppercase
/inventory/name.uppercase()
</code></pre>

<h5>
<a name="string-lowecase" class="anchor" href="#string-lowecase"><span class="octicon octicon-link"></span></a><strong>String lowecase()</strong>
</h5>

<p>turns every character to lowercase</p>

<pre><code>// inventory’s name to lowercase
/inventory/name.lowercase()
</code></pre>

<h5>
<a name="double-length" class="anchor" href="#double-length"><span class="octicon octicon-link"></span></a><strong>double length()</strong>
</h5>

<p>returns the length of the string</p>

<pre><code>// inventory’s name length
/inventory/name.length()
</code></pre>

<h5>
<a name="boolean-startswithstring-prefix" class="anchor" href="#boolean-startswithstring-prefix"><span class="octicon octicon-link"></span></a><strong>boolean startsWith(String prefix)</strong>
</h5>

<p>returns <em>true</em> if the string starts with <code>prefix</code></p>

<pre><code>// check inventory’s name prefix
/inventory/name.startsWith("Inv")
</code></pre>

<h5>
<a name="boolean-endswithstring-suffix" class="anchor" href="#boolean-endswithstring-suffix"><span class="octicon octicon-link"></span></a><strong>boolean endsWith(String suffix)</strong>
</h5>

<p>returns <em>true</em> if the string ends with <code>suffix</code></p>

<pre><code>// check inventory’s name suffix
/inventory/name.endsWith("YZ")
</code></pre>

<h5>
<a name="boolean-containsstring-s" class="anchor" href="#boolean-containsstring-s"><span class="octicon octicon-link"></span></a><strong>boolean contains(String s)</strong>
</h5>

<p>returns <em>true</em> if the string contains <code>s</code></p>

<pre><code>// check if inventory’s name contains "ABC"
/inventory/name.contains("ABC")
</code></pre>

<h5>
<a name="string-concatstring-s1-string-s2-" class="anchor" href="#string-concatstring-s1-string-s2-"><span class="octicon octicon-link"></span></a><strong>String concat(String s1, String s2, ...)</strong>
</h5>

<p>returns the concatenation of the string with <code>s1</code>, <code>s2</code>, etc...</p>

<pre><code>// concatenate two strings to the title of the first book
/inventory/book[1]/title.concat("is", "the 1st Book")
</code></pre>

<h5>
<a name="string-substringint-beginindex-int-endindex" class="anchor" href="#string-substringint-beginindex-int-endindex"><span class="octicon octicon-link"></span></a><strong>String substring(int beginIndex, int endIndex)</strong>
</h5>

<p>extracts the characters, between two specified indexes, and returns the new substring</p>

<pre><code>// substring of the first book’s title
/inventory/book[1]/title.substring(0, 2)
</code></pre>

<h5>
<a name="string-replacestring-target-string-replacement" class="anchor" href="#string-replacestring-target-string-replacement"><span class="octicon octicon-link"></span></a><strong>String replace(String target, String replacement)</strong>
</h5>

<p>replace every occurrence of <code>target</code> with <code>replacement</code></p>

<pre><code>// substitutes blank spaces with underscores, in first book’s title
/inventory/book[1]/title.replace(" ", "_")
</code></pre>

<p><a name="double"></a></p>

<h3>
<a name="double" class="anchor" href="#double"><span class="octicon octicon-link"></span></a>Double</h3>

<p>The general representation of every number, which are parsed and used as a signed double.</p>

<h4>
<a name="functions-3" class="anchor" href="#functions-3"><span class="octicon octicon-link"></span></a>Functions</h4>

<p>For numbers, the available functions can be used for manipulations and rounding. The list is a subset of the functions offered by XPath.</p>

<h5>
<a name="double-abs" class="anchor" href="#double-abs"><span class="octicon octicon-link"></span></a><strong>double abs()</strong>
</h5>

<p>gives the absolute value of the number on which it is applied</p>

<pre><code>// suppose variable $a is defined equals to -1
$a.abs() // result is 1.0
</code></pre>

<h5>
<a name="double-ceiling" class="anchor" href="#double-ceiling"><span class="octicon octicon-link"></span></a><strong>double ceiling()</strong>
</h5>

<p>returns the smallest integer that is greater than the number argument</p>

<pre><code>// ceiling of the first book’s price (suppose 9.9)
/inventory/book[1]/price.ceiling() // result is 10.0
</code></pre>

<h5>
<a name="double-floor" class="anchor" href="#double-floor"><span class="octicon octicon-link"></span></a><strong>double floor()</strong>
</h5>

<p>returns the largest integer that is not greater than the number argument</p>

<pre><code>// floor of the first book’s price (suppose 9.9)
/inventory/book[1]/price.floor() // result is 9.0
</code></pre>

<h5>
<a name="double-round" class="anchor" href="#double-round"><span class="octicon octicon-link"></span></a><strong>double round()</strong>
</h5>

<p>rounds the number argument to the nearest integer</p>

<pre><code>// rounded price of the first book (suppose 9.9)
/inventory/book[1]/price.round() // result is 10.0
</code></pre>

<h5>
<a name="double-roundhalftoeven" class="anchor" href="#double-roundhalftoeven"><span class="octicon octicon-link"></span></a><strong>double roundHalfToEven()</strong>
</h5>

<p>rounds a number with .5 fraction to the nearest even integer</p>

<pre><code>// rounded price of the first book (suppose 9.5)
/inventory/book[1]/price.roundHalfToEven() // result is 10.0
</code></pre>

<h5>
<a name="string-tostring" class="anchor" href="#string-tostring"><span class="octicon octicon-link"></span></a><strong>String toString()</strong>
</h5>

<p>returns the string representation of the number</p>

<pre><code>// string representation of the first book’s price
/inventory/book[1]/price.toString() // result "15.0"
</code></pre>

<p><a name="lexical_elems"></a></p>

<h3>
<a name="other-lexical-elements" class="anchor" href="#other-lexical-elements"><span class="octicon octicon-link"></span></a>Other Lexical Elements</h3>

<p><a name="comments"></a></p>

<h3>
<a name="comments" class="anchor" href="#comments"><span class="octicon octicon-link"></span></a>Comments</h3>

<p>There are two type of <em>comments</em>:</p>

<ul>
<li>
<strong>Line Comments</strong> start with the sequence <code>//</code> and stop at the end of line</li>
<li>
<strong>General Comments</strong> start with the sequence <code>/*</code> and continue until character sequence <code>*/</code>, it could contain more than one line</li>
</ul><p>Comments do not nest.</p>

<p><a name="keyword"></a></p>

<h3>
<a name="keyword" class="anchor" href="#keyword"><span class="octicon octicon-link"></span></a>Keyword</h3>

<p>The following keywords are reserved and may not be used as identifiers</p>

<pre><code>let       max       startsWith
in        min       endsWith
forall    sum       contains
exists    avg
numOf     product
</code></pre>

<p><a name="operators"></a></p>

<h3>
<a name="operators" class="anchor" href="#operators"><span class="octicon octicon-link"></span></a>Operators</h3>

<p>The following character sequences represent operators, delimiters, and other special tokens:</p>

<pre><code>==    +    &amp;&amp;    ,    (  )
!=    -    ||    ;    [  ]
&gt;     *    !     .
&lt;     /
&gt;=    %
&lt;=
=
</code></pre>

<p><a name="features"></a></p>

<h2>
<a name="features" class="anchor" href="#features"><span class="octicon octicon-link"></span></a>Features</h2>

<p>Specl structure present two main part: declaration part and assertions part.</p>

<p><em>Declarations part</em> has the purpose to let the user define variables that could be  used later for making assertions. The use of variables is not mandatory for the grammar, but is useful for simpler and clearer usage of the language.</p>

<p><em>Assertions part</em> of the grammar contains the set of constraints and values to check and keep controlled. It's the kernel of the language.<br>
Assertions are composed by using logical operators: NOT (<code>!</code>), AND (<code>&amp;&amp;</code>), OR (<code>||</code>). These have the usual priority: NOT &gt; AND &gt; OR. With brackets for change the priority, depending on the user's needs.<br>
Each <a href="#assertion"><em>assertion</em></a> consist of a comparison, using various operators, between two expressions.</p>

<p><a name="nav_query"></a></p>

<h3>
<a name="navigation-and-query" class="anchor" href="#navigation-and-query"><span class="octicon octicon-link"></span></a>Navigation and query</h3>

<p>At first, we will discuss about one of the basic functionality of the language: navigation path expressions and query. Those let the user querying and retrieving data values from an SDO using a notation inspired by <a href="http://www.w3.org/TR/xpath" target="_blank">XPath</a>.</p>

<p>The queries are built by steps, separated by a slash (<code>/</code>): at each step, the specified element (conforming to a key property in the SDO) is selected and the corresponding value is returned.</p>

<p>As in XPath, there are predicates used to restrict the node-set by selecting only those nodes for which a specified condition is true; acceptable predicates enable the selection of a node by its value or by its position:</p>

<pre><code>// select the 'step1' whose 'step2' is greater or equal than 1
let $a = /step1[step2 &gt;= 1];

// select the 'step1' whose 'step3' is equal to "String"
let $b = /step1[step3 == ”String”];

// select the first of the 'step1' nodes
let $c = /step1[1];
</code></pre>

<p>The form in the first two cases is</p>

<blockquote>
<p>[ <em>node</em> op <em>value</em> ]</p>
</blockquote>

<p>Where</p>

<ul>
<li>
<strong>node</strong>: the name of the node to test</li>
<li>
<strong>op</strong>: the operation to apply (note that only <code>==</code> and <code>!=</code> has sense when <em>value</em> is a String)</li>
<li>
<strong>value</strong>: the value to compare, could be a String, a number or a <em>Variable</em>
</li>
</ul><p>In the last example, the parentheses contain just a number, that number refers to the index of the item to select.</p>

<p><a name="declaration"></a></p>

<h3>
<a name="declaration" class="anchor" href="#declaration"><span class="octicon octicon-link"></span></a>Declaration</h3>

<p>Allows you to assign a value to a variable. This variable can then be used almost anywhere in the code that follows it, and there can no longer be assigned a different value.</p>

<p>Declaration syntax:</p>

<blockquote>
<p>let <em>$var</em> = <em>value</em> ;</p>
</blockquote>

<p>Where:</p>

<ul>
<li>
<strong>let</strong>: is the keyword for starting a declaration</li>
<li>
<strong>$var</strong>: is the name of the assigned variable</li>
<li>
<strong>value</strong>: is the value to store</li>
<li>'<strong>;</strong>' : is the termination character</li>
</ul><p>The <em>value</em> could be directly declared when it's a constant (a number, a string, a Boolean or an array - see <a href="#data_types">data types</a>), or it could be the result of an <a href="#assertion">assertion</a> (the value corresponding to a certain <a href="#nav_query">navigation path</a> or the result of an expression or a <a href="#quant_aggr_assertion">quantified assertion</a>).<br>
Here's some examples:</p>

<pre><code>let $number = 10;
let $string = "Hello World!";
let $array = [1, 2, 3];
let $assertion = /path/to/the/value;
let $assertion_exp = 2 * ($number - 1); // multiply 2 and (10 - 1)
let $quantified_assertion = numOf($elem in $array, $elem &gt; 1); // result is 2
</code></pre>

<p><a name="assertion"></a></p>

<h3>
<a name="assertion" class="anchor" href="#assertion"><span class="octicon octicon-link"></span></a>Assertion</h3>

<p>With the term <em>assertion</em> we intend <em>true/false</em> statement achieved with a comparison between expressions.
The comparison can be made with the use of operations like equal (<code>==</code>), unequal (<code>!=</code>), greater (<code>&gt;</code>), lower (<code>&lt;</code>), greater or equal (<code>&gt;=</code>) and lower or equal (<code>&lt;=</code>).<br></p>

<p>Each operation has sense with respect to the expressions type. The numeric assertions are the only ones that has access to the whole set of operands. In the next table, for each data type, are shown available operations and explained particular cases (see boolean expressions):</p>

<table>
<thead><tr>
<th align="center">Operation</th>
<th align="center">SDO</th>
<th align="center">Array</th>
<th align="center">Number</th>
<th align="center">String</th>
<th align="center">Boolean</th>
</tr></thead>
<tbody>
<tr>
<td align="center"><code>==</code></td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">implicit*</td>
</tr>
<tr>
<td align="center"><code>!=</code></td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">implicit*</td>
</tr>
<tr>
<td align="center"><code>&gt;</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">✓</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&gt;=</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">✓</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&lt;</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">✓</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&lt;=</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">✓</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody>
</table><p>(*) in the case of a comparison between Boolean expressions, the operation and <em>true</em> result becomes implicit and must be removed (for example the right one is <code>$a.contains("string")</code> and not <code>$a.contains("string") == true</code>). If the assertion checks <em>false</em> the expression is negated (<code>!($a.contains("string"))</code>).</p>

<p>The members of an assertion can be:</p>

<ul>
<li>query (see <a href="#nav_query">Navigation and query</a>)</li>
<li>constant (numeric or string)</li>
<li>array</li>
<li>quantified assertion (see <a href="#quant_aggr_assertion">Quantified Assertion &amp; Aggregated Functions</a>)</li>
<li>numeric expression (see <a href="#num_expr">Numeric Expression</a>)</li>
<li>variable</li>
</ul><p>Examples of few possible statements composition</p>

<pre><code>// query == string constant
/inventory/name == "InventoryABCD";
// variable &gt;= numeric constant
$price &gt;= 2;
</code></pre>

<p><a name="quant_aggr_assertion"></a></p>

<h4>
<a name="quantified-assertion--aggregated-functions" class="anchor" href="#quantified-assertion--aggregated-functions"><span class="octicon octicon-link"></span></a>Quantified Assertion &amp; Aggregated Functions</h4>

<p>These are assertions that iterate over a finite set of values and check every contained element with respect to the conditions.</p>

<p>The objective is to give the possibility to express constraints using universal and existential quantifier or aggregated functions. The statement is in the following form:</p>

<blockquote>
<p><em>quantifier</em> (<em>alias</em> in <em>var</em>, <em>conditions</em>)</p>
</blockquote>

<p>Where:</p>

<ul>
<li>
<strong>quantifier</strong>: the name of the used quantifier/function (see the table below for details)</li>
<li>
<strong>alias</strong>: a temp variable that will be used as parameter in the upcoming conditions</li>
<li>
<strong>var</strong>: the variable to which the iteration is applied, it defines the range of values that the <em>alias</em> can assume (<em>var</em> must be an array)</li>
<li>
<strong>conditions</strong>: the set of assertions to test at every iteration</li>
</ul><p>List of functions and their characteristics</p>

<table>
<thead><tr>
<th align="center">Name</th>
<th align="center">Returns</th>
<th align="left">Description</th>
</tr></thead>
<tbody>
<tr>
<td align="center">forall</td>
<td align="center">Boolean</td>
<td align="left">True if, for every element, the conditions are respected</td>
</tr>
<tr>
<td align="center">exists</td>
<td align="center">Boolean</td>
<td align="left">True if, for at least one element, the conditions are respected</td>
</tr>
<tr>
<td align="center">numOf</td>
<td align="center">Double</td>
<td align="left">the number of elements that respects the conditions</td>
</tr>
<tr>
<td align="center">max</td>
<td align="center">Double</td>
<td align="left">Returns the maximum element that respects the conditions</td>
</tr>
<tr>
<td align="center">min</td>
<td align="center">Double</td>
<td align="left">Returns the minimum element that respects the conditions</td>
</tr>
<tr>
<td align="center">avg</td>
<td align="center">Double</td>
<td align="left">Returns the average of the elements that respects the conditions</td>
</tr>
<tr>
<td align="center">sum</td>
<td align="center">Double</td>
<td align="left">Returns the sum of elements that respects the conditions</td>
</tr>
<tr>
<td align="center">product</td>
<td align="center">Double</td>
<td align="left">Returns the product of elements that respects the conditions</td>
</tr>
</tbody>
</table><p><a name="num_expr"></a></p>

<h4>
<a name="numeric-expression" class="anchor" href="#numeric-expression"><span class="octicon octicon-link"></span></a>Numeric Expression</h4>

<p>Use and evaluate expressions, using the canonical operands: sum (<code>+</code>), subtraction (<code>-</code>), multiplication (<code>*</code>), division (<code>/</code>) and modulo (<code>%</code>). Expressions has left associativity, and priorities between these operators is exactly as they are listed before (<code>%</code>, <code>/</code> and <code>*</code> has greater priority than <code>+</code> and <code>-</code>). As usual, precedence could be modified with brackets.</p>

<p>Expressions can also be calculated using navigation path and variables, as long as they return numeric values.</p>

<p>Example:</p>

<pre><code>// a simple expression using sum, multiplication and modulo
(1 + 1) * 1 % 1 == 0;
</code></pre>

<p><a name="grammar"></a></p>

<h2>
<a name="grammar" class="anchor" href="#grammar"><span class="octicon octicon-link"></span></a>Grammar</h2>

<p>The syntax is specified using Extended Backus-Naur Form (EBNF): </p>

<div class="highlight highlight-ANTLR"><pre><span class="nl">Model</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="on">Declaration</span><span class="o">*</span><span class="w"> </span><span class="on">Assertions</span><span class="w"> </span><span class="s">';'</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>

<span class="nl">Declaration</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="s">'let'</span><span class="w"> </span><span class="on">Variable</span><span class="w"> </span><span class="s">'in'</span><span class="w"> </span><span class="on">Assertion</span><span class="w"> </span><span class="s">';'</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>

<span class="nl">Assertions</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="on">PrimaryAssertions</span><span class="w"> </span><span class="o">((</span><span class="s">'&amp;&amp;'</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">'||'</span><span class="o">)</span><span class="w"> </span><span class="on">PrimaryAssertions</span><span class="w"> </span><span class="o">)*</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>

<span class="nl">PrimaryAssertions</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="s">'('</span><span class="w"> </span><span class="on">Assertions</span><span class="w"> </span><span class="s">')'</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">'!('</span><span class="w"> </span><span class="on">Assertions</span><span class="w"> </span><span class="s">')'</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="on">Assertion</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>

<span class="nl">Assertion</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="on">Expression</span><span class="w"> </span><span class="on">Rop</span><span class="w"> </span><span class="on">Expression</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>

<span class="nl">Expression</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="on">Step</span><span class="o">+</span><span class="w"> </span><span class="o">(</span><span class="s">'.'</span><span class="w"> </span><span class="on">Function</span><span class="o">)*</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">    </span><span class="on">NumericExpression</span><span class="w"> </span><span class="o">|</span><span class="w"> </span>
<span class="w">    </span><span class="on">AssertionQuantified</span><span class="w"> </span><span class="o">|</span><span class="w"> </span>
<span class="w">    </span><span class="on">Array</span><span class="w"> </span><span class="o">|</span><span class="w"> </span>
<span class="w">    </span><span class="on">Boolean</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>

<span class="nl">Step</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="s">'/'</span><span class="w"> </span><span class="on">ID</span><span class="w"> </span><span class="o">(</span><span class="s">'['</span><span class="w"> </span><span class="on">Predicate</span><span class="w"> </span><span class="s">']'</span><span class="o">)?</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="on">Variable</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>

<span class="nl">Predicate</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="on">ID</span><span class="w"> </span><span class="on">Rop</span><span class="w"> </span><span class="o">(</span><span class="on">STRING</span><span class="o">|</span><span class="on">NUMBER</span><span class="o">|</span><span class="on">Variable</span><span class="o">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="on">NUMBER</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="on">Variable</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>

<span class="nl">Function</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="on">ID</span><span class="w"> </span><span class="s">'('</span><span class="w"> </span><span class="o">(</span><span class="on">Values</span><span class="o">)?</span><span class="w"> </span><span class="s">')'</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>

<span class="nl">AssertionQuantified</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="on">Quantifier</span><span class="w"> </span><span class="s">'('</span><span class="w"> </span><span class="on">Variable</span><span class="w"> </span><span class="s">'in'</span><span class="w"> </span><span class="on">Variable</span><span class="p">,</span><span class="w"> </span><span class="on">Assertions</span><span class="w"> </span><span class="s">')'</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>

<span class="nl">Variable</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="s">'$'</span><span class="w"> </span><span class="on">ID</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>

<span class="nl">Rop</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="s">'=='</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">'!='</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">'&gt;'</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">'&gt;='</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">'&lt;'</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">'&lt;='</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>
</pre></div>
    
<p>Productions with first capital letter are refers to rules, upper case productions are terminals.</p>
        
</section>
      
</div>
    
    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Specl - Analyser maintained by <a href="https://github.com/samguinea">samguinea</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
