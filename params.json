{"name":"Specl - Analyser","tagline":"An Assertion Language for Service Data Object","body":"# Specl Language\r\n<a name=\"top\"></a>\r\nSpecl is a special-purpose assertion DSL for the expression of monitoring directives and constraint.\r\n\r\nSpecl concentrates on both functional and non-functional properties, and is suitable to express general dependability properties such as safety, integrity, availability and reliability.\r\n\r\nThe main strength of this language is that it relies on the concept of Service Data Object (SDO). This gives the language a single consistent view of data obtained from a variety of sources, and takes Specl to a more high level of abstraction. Specl acquires power and flexibility thanks to SDOs, allowing it to be used in various different contexts.\r\n\r\nIn this chapter, we will explain the language characteristics and features, decorating explanations with little examples (extracted and base on the work done in the [BookStore Example](#toy-example-book-store) for a better understanding. It would be useful at least a basic knowledge of navigational path and XPath.\r\n\r\nThe presentation will be done in a bottom-up fashion, from the data types to the whole grammar structure.\r\n\r\n## Table of Content\r\n\r\n1. [Data Types](#data-types)\r\n\t1. [SDO](#sdo)\r\n\t2. [Array](#array)\r\n\t3. [String](#string)\r\n\t4. [Number](#double)\r\n2. [Other Lexical Elements](#lexical_elems)\r\n\t1. [Comments](#comments)\r\n\t2. [Keyword](#keyword)\r\n\t3. [Operators](#operators)\r\n3. [Features](#features)\r\n  0. [Navigation & Query](#navigation-and-query)\r\n\t1. [Declaration](#declaration)\r\n\t2. [Assertions](#assertion)\r\n\t3. [Quantified Assertion & Aggregated Functions](#quantified-assertion--aggregated-functions)\r\n\t4. [Numeric Expression](#numeric-expression)\r\n4. [Grammar](#grammar)\r\n* [Examples](#examples)\r\n    * [Toy Example - Book Store](#toy-example-book-store)\r\n\t\t* [First Assertion](#example_toy_1)\r\n\t\t*\t[Second Assertion](#example_toy_2)\r\n\t\t* [Third Assertion](#example_toy_3)\r\n\t\t* [Fourth Assertion](#example_toy_4)\r\n\t\t* [Fifth Assertion](#example_toy_5)\r\n\t* [SOAP Handler](#example_handler)\r\n\t\t* [Server Side](#example_handler_server)\r\n\t\t\t- [Setup](#example_handler_server_setup)\r\n    \t\t\t+ [Needed Libraries](#example_handler_server_libs)\r\n\t\t\t\t+ [Installation](#example_handler_server_install)\r\n\t\t\t- [WS](#example_handler_server_wsclient)\r\n\t\t\t- [Server SOAP Handler](#example_handler_server_handler)\r\n\t\t\t- [Server SOAPHandler XML File](#example_handler_server_handler_xml)\r\n\t\t\t- [Attach Handler to BookstoreWS](#example_handler_server_handler_attach)\r\n\t\t\t- [BookstoreWS Project Organization](#example_handler_server_proj_dir_struct)\r\n\t\t\t- [Source](#example_handler_sources)\r\n\t\t* [Client Side](#example_handler_client)\r\n\t\t\t- [Setup](#example_handler_client_setup)\r\n\t\t\t\t+ [Needed Libraries](#example_handler_client_libs)\r\n\t\t\t\t+ [Installation](#example_handler_client_install)\r\n\t\t\t- [WS Client](#example_handler_client_wsclient)\r\n\t\t\t- [Client SOAP Handler](#example_handler_client_handler)\r\n\t\t\t- [Client SOAPHandler XML File](#example_handler_client_handler_xml)\r\n\t\t\t- [Attach Handler to BookstoreWS](#example_handler_client_handler_attach)\r\n\t\t\t- [BookstoreWS Client Project Organization](#example_handler_client_proj_dir_struct)\r\n\t\t\t- [Source](#example_handler_sources)\r\n\r\n\r\n<a name=\"data_types\"></a>\r\n## Data Types\r\nThe data types used inside the language are\r\n\r\n* SDO\r\n* Array\r\n* String\r\n* Double\r\n* Boolean\r\n\r\nEach of them as associated its own functions, that expands the power of the language and that could be easily upgraded and extended. SDO, as a containment object, could have values of each of the previously showed type, even another SDO.\r\n\r\n<a name=\"sdo\"></a>\r\n### SDO\r\nSDO was born for simplify and unify Service Oriented Architecture (SOA) data access and code, i.e. its purpose is to facilitate communication and, for this reason, are designed to deliver a uniform data access layer for heterogeneous data sources in a service-oriented architecture. Provides flexible data structures that allow data to be organized as graphs of objects (called _data object_) that are composed of _properties_. Properties can be single or many valued and can have other data objects as their values.\r\n\r\n#### Mapping Examples\r\nThe Specl interpreter, provided as final result of this thesis, gives the possibility to translate XML documents and JSON objects to SDO. Furthermore, thanks to the generality and abstraction of SDOs, developers could build their own translator for any type of data.\r\n\r\nFor example, starting from the next XML and JSON code could be obtained a simple SDO.\r\n\r\nXML:\r\n```XML\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<container>\r\n\t<elem1>String</elem1>\r\n\t<elem2>1</elem2>\r\n\t<elem3>A</elem3>\r\n\t<elem3>B</elem3>\r\n\t<elem3>C</elem3>\r\n\t<elem4>true</elem4>\r\n\t<elem5>\r\n\t\t<sub-elem1>String</sub-elem1>\r\n\t\t<sub-elem2>\r\n\t\t\t<sub-sub-elem1>10</sub-sub-elem1>\r\n\t\t</sub-elem2>\r\n\t\t<sub-elem3>1</sub-elem3>\r\n\t\t<sub-elem3>2</sub-elem3>\r\n\t</elem5>\r\n</container>\r\n```\r\nJSON:\r\n```JSON\r\n{\r\n\t\"elem1\": \"String\",\r\n\t\"elem2\": \"1\",\r\n\t\"elem3\": [\r\n\t\t\"A\",\r\n\t\t\"B\",\r\n\t\t\"C\"\r\n\t],\r\n\t\"elem4\": \"true\",\r\n\t\"elem5\": {\r\n\t\t\"sub-elem1\": \"String\",\r\n\t\t\"sub-elem2\": [\r\n\t\t\t\"10\"\r\n\t\t],\r\n\t\t\"sub-elem3\": [\r\n\t\t\t\"1\",\r\n\t\t\t\"2\"\r\n\t\t]\r\n\t}\r\n}\r\n```\r\n\r\nHere is the structure of the SDO derived from the previous languages:\r\n```\r\n{\r\n\tcontainer = {\r\n\t\telem1 = \"String\",\r\n\t\telem2 = 1,\r\n\t\telem3 = [\"A\", \"B\", \"C\"],\r\n\t\telem4 = true,\r\n\t\telem5 = {\r\n\t\t\tsub-elem1 = \"String\",\r\n\t\t\tsub-elem2 = {\r\n\t\t\t\tsub-sub-elem1 = 10\r\n\t\t\t},\r\n\t\t\tsub-elem3 = [1, 2]\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nAs you can see, the representation is pretty similar to JSON: sets of key-value entry and ordered lists of values.\r\n\r\n#### Functions\r\nSDO’s functions let the designer to operate both on the whole object and on the elements included into it (could be checked the presence of a certain property or get its value).\r\nThe following is the list of available functions (plus a short example for each one):\r\n\r\n##### __boolean contains(Object elem)__\r\nreturns _true_ if an object with elem value is contained (the research is deep)\r\n```\r\n// search \"Pocket\" string in the first book of the inventory\r\n/inventory/book[1].contains(\"Pocket\")\r\n```\r\n\r\n##### __Object get(int index)__\r\nreturns the value of the `index`-th node (the first element of the array has index equals to 1)\r\n```\r\n// returns the first book of the inventory\r\n/inventory.get(1)\r\n```\r\n\r\n##### __Object get(String node)__\r\nreturns the value of the node with name `node`\r\n```\r\n// get the value of the key \"name\"\r\n/inventory.get(\"name\")\r\n```\r\n\r\n##### __double cardinality()__\r\nreturns the number of elements contained\r\n```\r\n// get the number of values contained\r\n/inventory.cardinality();\r\n```\r\n\r\n<a name=\"array\"></a>\r\n### Array\r\nThe used type coincide with the classical kind of array, containing a finite number of elements. It is defined writing the elements of it inside square brackets and separated by commas (`[elem1, elem2, ...]`).\r\n\r\n#### Functions\r\nAvailable functions for arrays covers the basic general-purpose language functions for this kind of data type, working on elements or getting the size of the array:\r\n\r\n##### __boolean contains(Object elem)__\r\nreturns _true_ if the passed `elem` object is contained\r\n```\r\n// check if the second book is written by a certain author\r\n/inventory/book[2]/authors/author.contains(\"Larry Niven\")\r\n```\r\n\r\n##### __Object get(int index)__\r\nreturns the `index`-th element of the array\r\n```\r\n// get the second author from an array of authors,\r\n// from the second book\r\n/inventory/book[2]/authors/author.get(2)\r\n```\r\n\r\n##### __double cardinality()__\r\nreturns the length of the array\r\n```\r\n// get the length of the authors array of the second book\r\n/inventory/book[2]/authors/author.cardinality()\r\n```\r\n\r\n<a name=\"string\"></a>\r\n#### String\r\nRepresents a string constant obtained from a sequence of characters. Everything inside quotes is considered as string (double or single quote: `\"...\"` or `’...’`).\r\n\r\n##### Functions\r\nEven in this case, the functions are simple and common in many other contexts:\r\n\r\n##### __String uppercase()__\r\nturns every character to uppercase\r\n````\r\n// inventory’s name to uppercase\r\n/inventory/name.uppercase()\r\n```\r\n\r\n##### __String lowecase()__\r\nturns every character to lowercase\r\n```\r\n// inventory’s name to lowercase\r\n/inventory/name.lowercase()\r\n```\r\n\r\n##### __double length()__\r\nreturns the length of the string\r\n```\r\n// inventory’s name length\r\n/inventory/name.length()\r\n```\r\n\r\n##### __boolean startsWith(String prefix)__\r\nreturns _true_ if the string starts with `prefix`\r\n```\r\n// check inventory’s name prefix\r\n/inventory/name.startsWith(\"Inv\")\r\n```\r\n\r\n##### __boolean endsWith(String suffix)__\r\nreturns _true_ if the string ends with `suffix`\r\n```\r\n// check inventory’s name suffix\r\n/inventory/name.endsWith(\"YZ\")\r\n```\r\n\r\n##### __boolean contains(String s)__\r\nreturns _true_ if the string contains `s`\r\n```\r\n// check if inventory’s name contains \"ABC\"\r\n/inventory/name.contains(\"ABC\")\r\n```\r\n\r\n##### __String concat(String s1, String s2, ...)__\r\nreturns the concatenation of the string with `s1`, `s2`, etc...\r\n```\r\n// concatenate two strings to the title of the first book\r\n/inventory/book[1]/title.concat(\"is\", \"the 1st Book\")\r\n```\r\n\r\n##### __String substring(int beginIndex, int endIndex)__\r\nextracts the characters, between two specified indexes, and returns the new substring\r\n```\r\n// substring of the first book’s title\r\n/inventory/book[1]/title.substring(0, 2)\r\n```\r\n\r\n##### __String replace(String target, String replacement)__\r\nreplace every occurrence of `target` with `replacement`\r\n```\r\n// substitutes blank spaces with underscores, in first book’s title\r\n/inventory/book[1]/title.replace(\" \", \"_\")\r\n```\r\n\r\n<a name=\"double\"></a>\r\n### Double\r\nThe general representation of every number, which are parsed and used as a signed double.\r\n\r\n#### Functions\r\nFor numbers, the available functions can be used for manipulations and rounding. The list is a subset of the functions offered by XPath.\r\n\r\n##### __double abs()__\r\ngives the absolute value of the number on which it is applied\r\n```\r\n// suppose variable $a is defined equals to -1\r\n$a.abs() // result is 1.0\r\n```\r\n\r\n##### __double ceiling()__\r\nreturns the smallest integer that is greater than the number argument\r\n```\r\n// ceiling of the first book’s price (suppose 9.9)\r\n/inventory/book[1]/price.ceiling() // result is 10.0\r\n```\r\n\r\n##### __double floor()__\r\nreturns the largest integer that is not greater than the number argument\r\n```\r\n// floor of the first book’s price (suppose 9.9)\r\n/inventory/book[1]/price.floor() // result is 9.0\r\n```\r\n\r\n##### __double round()__\r\nrounds the number argument to the nearest integer\r\n```\r\n// rounded price of the first book (suppose 9.9)\r\n/inventory/book[1]/price.round() // result is 10.0\r\n```\r\n\r\n##### __double roundHalfToEven()__\r\nrounds a number with .5 fraction to the nearest even integer\r\n```\r\n// rounded price of the first book (suppose 9.5)\r\n/inventory/book[1]/price.roundHalfToEven() // result is 10.0\r\n```\r\n\r\n##### __String toString()__\r\nreturns the string representation of the number\r\n```\r\n// string representation of the first book’s price\r\n/inventory/book[1]/price.toString() // result \"15.0\"\r\n```\r\n\r\n<a name=\"lexical_elems\"></a>\r\n### Other Lexical Elements\r\n<a name=\"comments\"></a>\r\n### Comments\r\nThere are two type of _comments_:\r\n\r\n* __Line Comments__ start with the sequence `//` and stop at the end of line\r\n* __General Comments__ start with the sequence `/*` and continue until character sequence `*/`, it could contain more than one line\r\n \r\nComments do not nest.\r\n\r\n<a name=\"keyword\"></a>\r\n### Keyword\r\nThe following keywords are reserved and may not be used as identifiers\r\n```\r\nlet       max       startsWith\r\nin        min       endsWith\r\nforall    sum       contains\r\nexists    avg\r\nnumOf     product\r\n```\r\n\r\n<a name=\"operators\"></a>\r\n### Operators\r\n The following character sequences represent operators, delimiters, and other special tokens:\r\n```\r\n==    +    &&    ,    (  )\r\n!=    -    ||    ;    [  ]\r\n>     *    !     .\r\n<     /\r\n>=    %\r\n<=\r\n=\r\n```\r\n\r\n<a name=\"features\"></a>\r\n## Features\r\nSpecl structure present two main part: declaration part and assertions part.\r\n\r\n_Declarations part_ has the purpose to let the user define variables that could be  used later for making assertions. The use of variables is not mandatory for the grammar, but is useful for simpler and clearer usage of the language.\r\n\r\n_Assertions part_ of the grammar contains the set of constraints and values to check and keep controlled. It's the kernel of the language.<br/>\r\nAssertions are composed by using logical operators: NOT (`!`), AND (`&&`), OR (`||`). These have the usual priority: NOT > AND > OR. With brackets for change the priority, depending on the user's needs.<br/>\r\nEach [_assertion_](#assertion) consist of a comparison, using various operators, between two expressions.\r\n\r\n<a name=\"nav_query\"></a>\r\n### Navigation and query\r\nAt first, we will discuss about one of the basic functionality of the language: navigation path expressions and query. Those let the user querying and retrieving data values from an SDO using a notation inspired by <a href=\"http://www.w3.org/TR/xpath\" target=\"_blank\">XPath</a>.\r\n\r\nThe queries are built by steps, separated by a slash (`/`): at each step, the specified element (conforming to a key property in the SDO) is selected and the corresponding value is returned.\r\n\r\nAs in XPath, there are predicates used to restrict the node-set by selecting only those nodes for which a specified condition is true; acceptable predicates enable the selection of a node by its value or by its position:\r\n\r\n```\r\n// select the 'step1' whose 'step2' is greater or equal than 1\r\nlet $a = /step1[step2 >= 1];\r\n\r\n// select the 'step1' whose 'step3' is equal to \"String\"\r\nlet $b = /step1[step3 == ”String”];\r\n\r\n// select the first of the 'step1' nodes\r\nlet $c = /step1[1];\r\n```\r\n\r\nThe form in the first two cases is\r\n> [ _node_ op _value_ ]\r\n\r\nWhere\r\n\r\n* __node__: the name of the node to test\r\n* __op__: the operation to apply (note that only `==` and `!=` has sense when _value_ is a String)\r\n* __value__: the value to compare, could be a String, a number or a _Variable_\r\n\r\nIn the last example, the parentheses contain just a number, that number refers to the index of the item to select.\r\n\r\n<a name=\"declaration\"></a>\r\n### Declaration\r\nAllows you to assign a value to a variable. This variable can then be used almost anywhere in the code that follows it, and there can no longer be assigned a different value.\r\n\r\nDeclaration syntax:\r\n> let _$var_ = _value_ ;\r\n\r\nWhere:\r\n\r\n* __let__: is the keyword for starting a declaration\r\n* __$var__: is the name of the assigned variable\r\n* __value__: is the value to store\r\n* '__;__' : is the termination character\r\n\r\nThe _value_ could be directly declared when it's a constant (a number, a string, a Boolean or an array - see [data types](#data_types)), or it could be the result of an [assertion](#assertion) (the value corresponding to a certain [navigation path](#nav_query) or the result of an expression or a [quantified assertion](#quant_aggr_assertion)).<br/>\r\nHere's some examples:\r\n\r\n```\r\nlet $number = 10;\r\nlet $string = \"Hello World!\";\r\nlet $array = [1, 2, 3];\r\nlet $assertion = /path/to/the/value;\r\nlet $assertion_exp = 2 * ($number - 1); // multiply 2 and (10 - 1)\r\nlet $quantified_assertion = numOf($elem in $array, $elem > 1); // result is 2\r\n```\r\n\r\n<a name=\"assertion\"></a>\r\n### Assertion\r\nWith the term _assertion_ we intend _true/false_ statement achieved with a comparison between expressions.\r\nThe comparison can be made with the use of operations like equal (`==`), unequal (`!=`), greater (`>`), lower (`<`), greater or equal (`>=`) and lower or equal (`<=`).<br/>\r\n\r\nEach operation has sense with respect to the expressions type. The numeric assertions are the only ones that has access to the whole set of operands. In the next table, for each data type, are shown available operations and explained particular cases (see boolean expressions):\r\n\r\nOperation |   SDO    |   Array  |  Number  |  String  |  Boolean\r\n:--------:|:--------:|:--------:|:--------:|:--------:|:--------:\r\n`==`      | &#10003; | &#10003; | &#10003; | &#10003; | implicit*\r\n`!=`      | &#10003; | &#10003; | &#10003; | &#10003; | implicit*\r\n`>`       |          |       \t| &#10003; |          | \r\n`>=`      |     \t |       \t| &#10003; |          |\r\n`<`       |     \t |       \t| &#10003; |          |\r\n`<=`      |     \t |       \t| &#10003; |          |\r\n\r\n(*) in the case of a comparison between Boolean expressions, the operation and _true_ result becomes implicit and must be removed (for example the right one is `$a.contains(\"string\")` and not `$a.contains(\"string\") == true`). If the assertion checks _false_ the expression is negated (`!($a.contains(\"string\"))`).\r\n\r\nThe members of an assertion can be:\r\n\r\n* query (see [Navigation and query](#nav_query))\r\n* constant (numeric or string)\r\n* array\r\n* quantified assertion (see [Quantified Assertion & Aggregated Functions](#quant_aggr_assertion))\r\n* numeric expression (see [Numeric Expression](#num_expr))\r\n* variable\r\n\r\nExamples of few possible statements composition\r\n```\r\n// query == string constant\r\n/inventory/name == \"InventoryABCD\";\r\n// variable >= numeric constant\r\n$price >= 2;\r\n```\r\n\r\n<a name=\"quant_aggr_assertion\"></a>\r\n#### Quantified Assertion & Aggregated Functions\r\nThese are assertions that iterate over a finite set of values and check every contained element with respect to the conditions.\r\n\r\nThe objective is to give the possibility to express constraints using universal and existential quantifier or aggregated functions. The statement is in the following form:\r\n> _quantifier_ (_alias_ in _var_, _conditions_)\r\n\r\nWhere:\r\n\r\n* __quantifier__: the name of the used quantifier/function (see the table below for details)\r\n* __alias__: a temp variable that will be used as parameter in the upcoming conditions\r\n* __var__: the variable to which the iteration is applied, it defines the range of values that the _alias_ can assume (_var_ must be an array)\r\n* __conditions__: the set of assertions to test at every iteration\r\n\r\nList of functions and their characteristics\r\n\r\n  Name   | Returns |   Description\r\n:-------:|:-------:|:---------------\r\n forall  | Boolean | True if, for every element, the conditions are respected\r\n exists  | Boolean | True if, for at least one element, the conditions are respected\r\n numOf   | Double  |  the number of elements that respects the conditions\r\n max     | Double  | Returns the maximum element that respects the conditions\r\n min     | Double  | Returns the minimum element that respects the conditions\r\n avg     | Double  | Returns the average of the elements that respects the conditions\r\n sum     | Double  | Returns the sum of elements that respects the conditions\r\n product | Double  | Returns the product of elements that respects the conditions\r\n\r\n<a name=\"num_expr\"></a>\r\n#### Numeric Expression\r\nUse and evaluate expressions, using the canonical operands: sum (`+`), subtraction (`-`), multiplication (`*`), division (`/`) and modulo (`%`). Expressions has left associativity, and priorities between these operators is exactly as they are listed before (`%`, `/` and `*` has greater priority than `+` and `-`). As usual, precedence could be modified with brackets.\r\n\r\nExpressions can also be calculated using navigation path and variables, as long as they return numeric values.\r\n\r\nExample:\r\n```\r\n// a simple expression using sum, multiplication and modulo\r\n(1 + 1) * 1 % 1 == 0;\r\n```\r\n\r\n<a name=\"grammar\"></a>\r\n## Grammar\r\nThe syntax is specified using Extended Backus-Naur Form (EBNF): \r\n```ANTLR\r\nModel:\r\n    Declaration* Assertions ';'\r\n    \r\nDeclaration:\r\n    'let' Variable 'in' Assertion ';'\r\n    \r\nAssertions:\r\n    PrimaryAssertions (('&&' | '||') PrimaryAssertions )*\r\n    \r\nPrimaryAssertions:\r\n    '(' Assertions ')' | '!(' Assertions ')' | Assertion\r\n    \r\nAssertion:\r\n    Expression Rop Expression;\r\n    \r\nExpression:\r\n    Step+ ('.' Function)* |\r\n    NumericExpression | \r\n    AssertionQuantified | \r\n    Array | \r\n    Boolean\r\n;\r\n    \r\nStep:\r\n    '/' ID ('[' Predicate ']')? | Variable\r\n\r\nPredicate:\r\n    ID Rop (STRING|NUMBER|Variable) | NUMBER | Variable\r\n\r\nFunction:\r\n    ID '(' (Values)? ')'\r\n\r\nAssertionQuantified:\r\n    Quantifier '(' Variable 'in' Variable, Assertions ')'\r\n\r\nVariable:\r\n    '$' ID\r\n\r\nRop:\r\n    '==' | '!=' | '>' | '>=' | '<' | '<='\r\n```\r\n\r\nProductions with first capital letter are refers to rules, uppercase productions are terminals.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}